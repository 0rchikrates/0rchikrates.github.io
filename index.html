<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plato's Alcibiades I - Greek Text</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        .greek-text {
            font-family: 'Crimson Text', serif;
            font-size: 1.125rem;
            line-height: 1.75;
            color: #1f2937;
        }

        .text-section {
            background: white;
            margin-bottom: 2rem;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-left: 4px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .text-section:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
        }

        .speaker-name {
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #f3f4f6;
        }

        .speaker-name.socrates {
            color: #dc2626;
            border-bottom-color: #fecaca;
        }

        .speaker-name.alcibiades {
            color: #2563eb;
            border-bottom-color: #dbeafe;
        }

        .section-content {
            margin-bottom: 0;
        }

        .milestone {
            display: inline-block;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            margin: 0 0.5rem 0.5rem 0;
            border-radius: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .milestone.page {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .milestone.section {
            background: linear-gradient(135deg, #10b981, #047857);
            color: white;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
        }

        .milestone-container {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #f3f4f6;
        }

        .header-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .loading-animation {
            display: inline-block;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .5;
            }
        }

        .container-main {
            max-width: 5xl;
        }
    </style>
</head>
<body>
    <div class="min-h-screen">
        <!-- Header -->
        <header class="text-center py-16 px-4">
            <h1 class="text-6xl font-bold header-gradient mb-4">
                Πλάτωνος Ἀλκιβιάδης
            </h1>
            <p class="text-xl text-gray-600 mb-2">Plato's Alcibiades I</p>
            <p class="text-sm text-gray-500 uppercase tracking-wide">Perseus Digital Library • Beta Code to Unicode</p>
        </header>

        <!-- Main Content -->
        <main class="container mx-auto container-main px-4 pb-16">
            <div id="text-container" class="space-y-6">
                <div class="text-section">
                    <p class="text-gray-500 loading-animation">Loading ancient Greek text...</p>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="text-center py-8 px-4 border-t border-gray-200 bg-white/50">
            <p class="text-gray-500 text-sm">
                A scholarly text viewer for ancient Greek literature
            </p>
            <p class="text-gray-400 text-xs mt-2">
                Built with modern web technologies for classical studies
            </p>
        </footer>
    </div>


    <script>
        // --- Beta Code to Unicode Conversion ---
        function betaCodeToUnicode(betaCodeStr) {
            if (!betaCodeStr) return '';

            const betaCodeMap = {
                'A': 'α', 'B': 'β', 'C': 'ξ', 'D': 'δ', 'E': 'ε', 'F': 'φ', 'G': 'γ', 'H': 'η', 'I': 'ι', 'K': 'κ',
                'L': 'λ', 'M': 'μ', 'N': 'ν', 'O': 'ο', 'P': 'π', 'Q': 'θ', 'R': 'ρ', 'S': 'σ', 'T': 'τ', 'U': 'υ',
                'V': 'ς', 'W': 'ω', 'X': 'χ', 'Y': 'ψ', 'Z': 'ζ',
                ')': '̓', // Smooth breathing
                '(': '̔', // Rough breathing
                '/': '́', // Acute
                '=': '͂', // Circumflex
                '\\': '̀', // Grave
                '+': '̈', // Diaeresis
                '|': 'ͅ', // Iota subscript
            };

            const combinedChars = {
                'α': {'̓': 'ἀ', '̔': 'ἁ', '́': 'ά', '̀': 'ὰ', '͂': 'ᾶ', '̓́': 'ἄ', '̓̀': 'ἂ', '̓͂': 'ἆ', '̔́': 'ἅ', '̔̀': 'ἃ', '̔͂': 'ἇ'},
                'ε': {'̓': 'ἐ', '̔': 'ἑ', '́': 'έ', '̀': 'ὲ', '̓́': 'ἔ', '̓̀': 'ἒ', '̔́': 'ἕ', '̔̀': 'ἓ'},
                'η': {'̓': 'ἠ', '̔': 'ἡ', '́': 'ή', '̀': 'ὴ', '͂': 'ῆ', 'ͅ': 'ῃ', '̓́': 'ἤ', '̓̀': 'ἢ', '̓͂': 'ἦ', '̔́': 'ἥ', '̔̀': 'ἣ', '̔͂': 'ἧ', '̓ͅ': 'ᾐ', '̔ͅ': 'ᾑ', '́ͅ': 'ῄ', '̀ͅ': 'ῂ', '͂ͅ': 'ῇ'},
                'ι': {'̓': 'ἰ', '̔': 'ἱ', '́': 'ί', '̀': 'ὶ', '͂': 'ῖ', '̈': 'ϊ', '̓́': 'ἴ', '̓̀': 'ἲ', '̓͂': 'ἶ', '̔́': 'ἵ', '̔̀': 'ἳ', '̔͂': 'ἷ', '́̈': 'ΐ', '̀̈': 'ῒ'},
                'ο': {'̓': 'ὀ', '̔': 'ὁ', '́': 'ό', '̀': 'ὸ', '̓́': 'ὄ', '̓̀': 'ὂ', '̔́': 'ὅ', '̔̀': 'ὃ'},
                'υ': {'̓': 'ὐ', '̔': 'ὑ', '́': 'ύ', '̀': 'ὺ', '͂': 'ῦ', '̈': 'ϋ', '̓́': 'ὔ', '̓̀': 'ὒ', '̓͂': 'ὖ', '̔́': 'ὕ', '̔̀': 'ὓ', '̔͂': 'ὗ', '́̈': 'ΰ', '̀̈': 'ῢ'},
                'ω': {'̓': 'ὠ', '̔': 'ὡ', '́': 'ώ', '̀': 'ὼ', '͂': 'ῶ', 'ͅ': 'ῳ', '̓́': 'ὤ', '̓̀': 'ὢ', '̓͂': 'ὦ', '̔́': 'ὥ', '̔̀': 'ὣ', '̔͂': 'ὧ', '̓ͅ': 'ᾠ', '̔ͅ': 'ᾡ', '́ͅ': 'ῴ', '̀ͅ': 'ῲ', '͂ͅ': 'ῷ'},
                'ρ': {'̔': 'ῥ'}
            };
            
            const combinedCharsUpper = {
                'Α': {'̓': 'Ἀ', '̔': 'Ἁ', '́': 'Ά', '̀': 'Ὰ', '̓́': 'Ἄ', '̓̀': 'Ἂ', '̔́': 'Ἅ', '̔̀': 'Ἃ'},
                'Ε': {'̓': 'Ἐ', '̔': 'Ἑ', '́': 'Έ', '̀': 'Ὲ', '̓́': 'Ἔ', '̓̀': 'Ἒ', '̔́': 'Ἕ', '̔̀': 'Ἓ'},
                'Η': {'̓': 'Ἠ', '̔': 'Ἡ', '́': 'Ή', '̀': 'Ὴ', '̓́': 'Ἤ', '̓̀': 'Ἢ', '̔́': 'Ἥ', '̔̀': 'Ἣ', 'ͅ': 'ῌ', '̓ͅ': 'ᾘ', '̔ͅ': 'ᾙ'},
                'Ι': {'̓': 'Ἰ', '̔': 'Ἱ', '́': 'Ί', '̀': 'Ὶ', '̈': 'Ϊ', '̓́': 'Ἴ', '̓̀': 'Ἲ', '̔́': 'Ἵ', '̔̀': 'Ἳ'},
                'Ο': {'̓': 'Ὀ', '̔': 'Ὁ', '́': 'Ό', '̀': 'Ὸ', '̓́': 'Ὄ', '̓̀': 'Ὂ', '̔́': 'Ὅ', '̔̀': 'Ὃ'},
                'Υ': {'̔': 'Ὑ', '́': 'Ύ', '̀': 'Ὺ', '̈': 'Ϋ', '̔́': 'Ὕ', '̔̀': 'Ὓ'},
                'Ω': {'̓': 'Ὠ', '̔': 'Ὡ', '́': 'Ώ', '̀': 'Ὼ', '̓́': 'Ὤ', '̓̀': 'Ὢ', '̔́': 'Ὥ', '̔̀': 'Ὣ', 'ͅ': 'ῼ', '̓ͅ': 'ᾨ', '̔ͅ': 'ᾩ'},
                'Ρ': {'̔': 'Ῥ'}
            };

            let unicodeStr = "";
            let text = betaCodeStr.toUpperCase().trim();
            let i = 0;

            while (i < text.length) {
                let char = text[i];
                let isUpperCase = false;
                let diacritics = "";

                if (char === '*') {
                    isUpperCase = true;
                    i++;
                    char = text[i];
                }

                if (isUpperCase && '()'.includes(char)) {
                    diacritics += betaCodeMap[char];
                    i++;
                    char = text[i];
                }
                
                let mappedChar = betaCodeMap[char];

                if (mappedChar) {
                    while (i + 1 < text.length && '()/=\\+|'.includes(text[i + 1])) {
                        diacritics += betaCodeMap[text[i + 1]];
                        i++;
                    }

                    let finalChar;
                    if (isUpperCase) {
                        const upperBaseChar = mappedChar.toUpperCase();
                        finalChar = combinedCharsUpper[upperBaseChar]?.[diacritics] || (upperBaseChar + diacritics);
                    } else {
                        finalChar = combinedChars[mappedChar]?.[diacritics] || (mappedChar + diacritics);
                    }
                    unicodeStr += finalChar;
                } else {
                    unicodeStr += char;
                }
                i++;
            }
            
            // Final sigma conversion is tricky; a simple replace after the fact is more reliable
            // It replaces any sigma that is followed by a non-letter character or is at the end of the string.
            return unicodeStr.replace(/σ(?=[^α-ωΑ-Ω]|$)/g, 'ς');
        }

        
        // --- Enhanced Milestone and Section Handling ---
        function createMilestone(unit, n) {
            const milestone = document.createElement('span');
            milestone.className = `milestone ${unit}`;
            milestone.textContent = unit === 'page' ? `Page ${n}` : `§ ${n}`;
            return milestone;
        }

        function createTextSection() {
            const section = document.createElement('div');
            section.className = 'text-section';
            return section;
        }

        function getSpeakerClass(speakerName) {
            const name = speakerName.toLowerCase();
            if (name.includes('σω') || name.includes('socr')) return 'socrates';
            if (name.includes('αλκ') || name.includes('alcib')) return 'alcibiades';
            return '';
        }

        function processNode(node, container) {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.trim();
                if (text) {
                    const textNode = document.createTextNode(betaCodeToUnicode(text));
                    container.appendChild(textNode);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                if (node.tagName === 'milestone') {
                    const unit = node.getAttribute('unit');
                    const n = node.getAttribute('n');
                    if (unit && n) {
                        let milestoneContainer = container.querySelector('.milestone-container');
                        if (!milestoneContainer) {
                            milestoneContainer = document.createElement('div');
                            milestoneContainer.className = 'milestone-container';
                            container.insertBefore(milestoneContainer, container.firstChild);
                        }
                        milestoneContainer.appendChild(createMilestone(unit, n));
                    }
                } else {
                    for (let child of node.childNodes) {
                        processNode(child, container);
                    }
                }
            }
        }

        // --- XML Loading and Display ---
        
        function createMilestone(unit, n) {
            const milestone = document.createElement('span');
            milestone.className = `milestone ${unit}`;
            milestone.textContent = unit === 'page' ? `Page ${n}` : `§${n}`;
            return milestone;
        }

        function processNode(node, container) {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                if (text) {
                    const textNode = document.createTextNode(betaCodeToUnicode(text));
                    container.appendChild(textNode);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                if (node.tagName === 'milestone') {
                    const unit = node.getAttribute('unit');
                    const n = node.getAttribute('n');
                    if (unit && n) {
                        container.appendChild(createMilestone(unit, n));
                        container.appendChild(document.createTextNode(' '));
                    }
                } else if (node.tagName === 'add' || node.tagName === 'del') {
                    // Skip rendering content of <add> and <del> tags for a cleaner text
                    return;
                }
                else {
                    for (let child of node.childNodes) {
                        processNode(child, container);
                    }
                }
            }
        }

        async function loadAndDisplayText() {
            const container = document.getElementById('text-container');
            
            try {
                const response = await fetch('Perseus_text_1999.01.0175.xml');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const xmlText = await response.text();

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
                
                container.innerHTML = '';
                
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    container.innerHTML = `<p class="text-red-500"><strong>XML Parse Error:</strong> ${parseError.textContent}</p>`;
                    return;
                }
                
                // Find the first text body to display (e.g., Alc. 1)
                const body = xmlDoc.querySelector('text[n="Alc. 1"] > body');
                if (!body) {
                    container.innerHTML = '<p class="text-red-500">Could not find the text body for Alcibiades 1 in the XML file.</p>';
                    return;
                }
                
                let speakerBlocks = body.getElementsByTagName('sp');

                Array.from(speakerBlocks).forEach(block => {
                    const speakerElement = block.getElementsByTagName('speaker')[0];
                    const paragraphElements = block.getElementsByTagName('p');
                    
                    if (speakerElement) {
                        const speakerDiv = document.createElement('div');
                        speakerDiv.className = 'speaker';
                        speakerDiv.textContent = betaCodeToUnicode(speakerElement.textContent);
                        container.appendChild(speakerDiv);
                    }
                    
                    Array.from(paragraphElements).forEach(p_el => {
                         const p = document.createElement('p');
                         processNode(p_el, p);
                         container.appendChild(p);
                    });
                });

            } catch (error) {
                console.error('Error loading or parsing XML:', error);
                container.innerHTML = `<p class="text-red-500"><strong>Error:</strong> Could not load the text. Error: ${error.message}</p>`;
            }
        }

        document.addEventListener('DOMContentLoaded', loadAndDisplayText);
    </script>
</body>
</html>
