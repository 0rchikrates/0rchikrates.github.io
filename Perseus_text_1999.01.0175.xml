<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plato's Alcibiades - Greek Text</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for clean typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the Greek text paragraphs */
        .greek-text p {
            margin-bottom: 1.5rem;
            line-height: 1.8;
            font-size: 1.25rem;
        }
        .speaker {
            font-weight: 700;
            color: #111827; /* gray-900 */
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-12">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-gray-900">Plato's Alcibiades</h1>
            <p class="text-lg text-gray-600 mt-2">Rendered from Beta Code XML</p>
        </header>

        <!-- The Greek text will be loaded here -->
        <main id="text-container" class="bg-white p-8 rounded-lg shadow-md greek-text">
            <p class="text-gray-500">Loading text...</p>
        </main>

        <footer class="text-center mt-10 text-gray-500 text-sm">
            <p>A simple Greek text viewer. Built for GitHub Pages.</p>
        </footer>
    </div>

    <script>
        // --- Beta Code to Unicode Conversion ---
        // This is the core logic that translates the text.

        /**
         * Converts a string from Greek Beta Code to Unicode.
         * Handles capitalization, diacritics, and final sigmas.
         * @param {string} betaCodeStr The Beta Code string to convert.
         * @returns {string} The converted Unicode string.
         */
        function betaCodeToUnicode(betaCodeStr) {
            if (!betaCodeStr) return ''; // Return empty string if input is null or undefined
            
            const betaCodeMap = {
                'A': 'α', 'B': 'β', 'C': 'ξ', 'D': 'δ', 'E': 'ε', 'F': 'φ', 'G': 'γ', 'H': 'η', 'I': 'ι', 'K': 'κ',
                'L': 'λ', 'M': 'μ', 'N': 'ν', 'O': 'ο', 'P': 'π', 'Q': 'θ', 'R': 'ρ', 'S': 'σ', 'T': 'τ', 'U': 'υ',
                'V': 'ς', 'W': 'ω', 'X': 'χ', 'Y': 'ψ', 'Z': 'ζ',
                ')': '̓', // Smooth breathing
                '(': '̔', // Rough breathing
                '/': '́', // Acute
                '=': '͂', // Circumflex
                '\\': '̀', // Grave
                '+': '̈', // Diaeresis
                '|': 'ͅ', // Iota subscript
            };

            // Pre-combined characters for vowels with diacritics
            const combinedChars = {
                'α': {'̓': 'ἀ', '̔': 'ἁ', '́': 'ά', '̀': 'ὰ', '͂': 'ᾶ', '̓́': 'ἄ', '̓̀': 'ἂ', '̓͂': 'ἆ', '̔́': 'ἅ', '̔̀': 'ἃ', '̔͂': 'ἇ'},
                'ε': {'̓': 'ἐ', '̔': 'ἑ', '́': 'έ', '̀': 'ὲ', '̓́': 'ἔ', '̓̀': 'ἒ', '̔́': 'ἕ', '̔̀': 'ἓ'},
                'η': {'̓': 'ἠ', '̔': 'ἡ', '́': 'ή', '̀': 'ὴ', '͂': 'ῆ', 'ͅ': 'ῃ', '̓́': 'ἤ', '̓̀': 'ἢ', '̓͂': 'ἦ', '̔́': 'ἥ', '̔̀': 'ἣ', '̔͂': 'ἧ', '̓ͅ': 'ᾐ', '̔ͅ': 'ᾑ', '́ͅ': 'ῄ', '̀ͅ': 'ῂ', '͂ͅ': 'ῇ'},
                'ι': {'̓': 'ἰ', '̔': 'ἱ', '́': 'ί', '̀': 'ὶ', '͂': 'ῖ', '̈': 'ϊ', '̓́': 'ἴ', '̓̀': 'ἲ', '̓͂': 'ἶ', '̔́': 'ἵ', '̔̀': 'ἳ', '̔͂': 'ἷ', '́̈': 'ΐ', '̀̈': 'ῒ'},
                'ο': {'̓': 'ὀ', '̔': 'ὁ', '́': 'ό', '̀': 'ὸ', '̓́': 'ὄ', '̓̀': 'ὂ', '̔́': 'ὅ', '̔̀': 'ὃ'},
                'υ': {'̓': 'ὐ', '̔': 'ὑ', '́': 'ύ', '̀': 'ὺ', '͂': 'ῦ', '̈': 'ϋ', '̓́': 'ὔ', '̓̀': 'ὒ', '̓͂': 'ὖ', '̔́': 'ὕ', '̔̀': 'ὓ', '̔͂': 'ὗ', '́̈': 'ΰ', '̀̈': 'ῢ'},
                'ω': {'̓': 'ὠ', '̔': 'ὡ', '́': 'ώ', '̀': 'ὼ', '͂': 'ῶ', 'ͅ': 'ῳ', '̓́': 'ὤ', '̓̀': 'ὢ', '̓͂': 'ὦ', '̔́': 'ὥ', '̔̀': 'ὣ', '̔͂': 'ὧ', '̓ͅ': 'ᾠ', '̔ͅ': 'ᾡ', '́ͅ': 'ῴ', '̀ͅ': 'ῲ', '͂ͅ': 'ῷ'},
                'ρ': {'̔': 'ῥ'}
            };

            let unicodeStr = '';
            let isUpperCase = false;
            let text = betaCodeStr.toUpperCase().trim();

            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                
                if (char === '*') {
                    isUpperCase = true;
                    continue;
                }
                
                let mappedChar = betaCodeMap[char];
                
                if (mappedChar) {
                    let diacritics = '';
                    while (i + 1 < text.length && '()=/\\+|'.includes(text[i + 1])) {
                        diacritics += betaCodeMap[text[i + 1]];
                        i++;
                    }

                    let baseChar = mappedChar;
                    let finalChar = baseChar;
                    
                    if (diacritics && combinedChars[baseChar]) {
                        const sortedDiacritics = diacritics.split('').sort().join('');
                        if(combinedChars[baseChar][sortedDiacritics]) {
                             finalChar = combinedChars[baseChar][sortedDiacritics];
                        } else if (combinedChars[baseChar][diacritics]) {
                            finalChar = combinedChars[baseChar][diacritics];
                        } else {
                            finalChar = baseChar + diacritics;
                        }
                    }

                    if (isUpperCase) {
                        finalChar = finalChar.toUpperCase();
                        isUpperCase = false;
                    } else if (baseChar === 'σ' && (i === text.length - 1 || !text[i + 1].match(/[A-Z]/))) {
                        finalChar = 'ς';
                    }
                    
                    unicodeStr += finalChar;
                } else {
                    unicodeStr += char;
                    isUpperCase = false;
                }
            }
            return unicodeStr;
        }


        // --- XML Loading and Display ---
        
        /**
         * Fetches and parses the XML file, converts the content,
         * and displays it on the page.
         */
        async function loadAndDisplayText() {
            const container = document.getElementById('text-container');
            
            try {
                // Fixed filename to match the document source
                const response = await fetch('Perseus_text_1999.01.0175.xml');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const xmlText = await response.text();

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
                
                container.innerHTML = '';
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    container.innerHTML = `<p class="text-red-500"><strong>XML Parse Error:</strong> ${parseError.textContent}</p>`;
                    return;
                }
                
                // Try multiple possible structures for Perseus XML files
                let speakerBlocks = xmlDoc.getElementsByTagName('sp');
                
                // If no <sp> blocks found, try looking for other structures
                if (speakerBlocks.length === 0) {
                    // Try looking for div elements with type="speech"
                    const divs = xmlDoc.getElementsByTagName('div');
                    const speechDivs = [];
                    for (let div of divs) {
                        if (div.getAttribute('type') === 'speech') {
                            speechDivs.push(div);
                        }
                    }
                    
                    if (speechDivs.length > 0) {
                        // Process speech divs
                        speechDivs.forEach(div => {
                            // Look for speaker in various possible locations
                            let speakerElement = div.querySelector('speaker') || div.querySelector('head');
                            let speakerText = speakerElement ? speakerElement.textContent : '';
                            
                            // Get all paragraphs in this div
                            const paragraphs = div.getElementsByTagName('p');
                            
                            if (speakerText) {
                                const speakerDiv = document.createElement('div');
                                speakerDiv.className = 'speaker';
                                speakerDiv.textContent = betaCodeToUnicode(speakerText);
                                container.appendChild(speakerDiv);
                            }
                            
                            for (let p of paragraphs) {
                                const pElement = document.createElement('p');
                                pElement.textContent = betaCodeToUnicode(p.textContent);
                                container.appendChild(pElement);
                            }
                        });
                        return;
                    }
                    
                    // If still no luck, try to display any paragraphs found
                    const allParagraphs = xmlDoc.getElementsByTagName('p');
                    if (allParagraphs.length > 0) {
                        container.innerHTML = '<div class="speaker">Text Content</div>';
                        for (let p of allParagraphs) {
                            const pElement = document.createElement('p');
                            pElement.textContent = betaCodeToUnicode(p.textContent);
                            container.appendChild(pElement);
                        }
                        return;
                    }
                    
                    // Last resort: show XML structure for debugging
                    container.innerHTML = `
                        <div class="text-red-500">
                            <p><strong>No recognizable structure found.</strong></p>
                            <p>Root element: ${xmlDoc.documentElement.tagName}</p>
                            <p>Available elements: ${Array.from(new Set(Array.from(xmlDoc.getElementsByTagName('*')).map(el => el.tagName))).join(', ')}</p>
                            <p>Please check the XML file structure.</p>
                        </div>
                    `;
                    return;
                }

                // Process standard <sp> blocks
                Array.from(speakerBlocks).forEach(block => {
                    const speakerElement = block.getElementsByTagName('speaker')[0];
                    const paragraphElement = block.getElementsByTagName('p')[0];
                    
                    const speakerNameBeta = speakerElement?.textContent;
                    const paragraphBeta = paragraphElement?.textContent;

                    // Convert both to Unicode
                    const speakerNameUnicode = betaCodeToUnicode(speakerNameBeta);
                    const paragraphUnicode = betaCodeToUnicode(paragraphBeta);

                    // Create elements to display the content
                    if (speakerNameUnicode) {
                        const speakerDiv = document.createElement('div');
                        speakerDiv.className = 'speaker';
                        speakerDiv.textContent = speakerNameUnicode;
                        container.appendChild(speakerDiv);
                    }
                    
                    if (paragraphUnicode) {
                        const p = document.createElement('p');
                        p.textContent = paragraphUnicode;
                        container.appendChild(p);
                    }
                });

            } catch (error) {
                console.error('Error loading or parsing XML:', error);
                container.innerHTML = `<p class="text-red-500"><strong>Error:</strong> Could not load the text. Please check if the 'Perseus_text_1999.01.0175.xml' file exists and is accessible. Error: ${error.message}</p>`;
            }
        }

        // Run the function after the page has loaded
        document.addEventListener('DOMContentLoaded', loadAndDisplayText);
    </script>
</body>
</html>
